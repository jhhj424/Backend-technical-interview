# 데이터베이스
## 트랜잭션

데이터베이스, 상태변화, 논리적, 작업단위, 연산 집합

## 트랜잭션 성질(ACID)

원자성, 일관성, 독립성, 지속성

원자성 : 모든 연산 수행완료 or 수행실패

일관성 : 트랜잭션이 끝난 후 데이터베이스는 일관된 상태

격리성 : 다른 트랜잭션 참조 불가

영속성 : 영원히 저장

## 트랜잭션 격리수준

ANSI표준, 격리성과 동시처리성능 트레이드오프

격리수준이 높아지면 이슈는 적지만 동시 처리 성능이 떨어짐

Read Uncommitted: 커밋 안되도 읽을 수 있음

Read Committed: 커밋된 데이터만 읽을 수 있음

Repeatable Read: 같은 트랜잭션 내에선 계속 같은 데이터를 조회함

Serializable: 모든 조회에 락이 걸림, 동시성 떨어짐, 이슈 없음

## 조인

여러 테이블, 레코드, 조합, 하나의 열로 표현

## 인덱스(Index)

책, 색인, 조회 성능 향상, 비트리 자료구조

무분별한 인덱스 성능 하락

데이터의 변경에는 안좋음

## B+Tree 자료구조

루트, 브랜치, 리프 블록(노드)로 구성

Select 질의의 범위 연산 때문에 해쉬테이블X

## 파티셔닝

대용량 데이터, 성능, 가용성, 관리용이성

수평, 수직, 분할, 같은(하나의) 데이터베이스

단점: 조인 비용 증가

## 샤딩

수평, 분할, 다른(여러개) 데이터베이스

## ORM(Object Relational Mapping)

객체관계매핑

## 영속성

데이터 생성 프로그램 종료, 데이터는 사라지지 않음 - DB를 사용

## Persistence layer

프로그램 아키텍처에서 데이터 영속성 부여 계층

JDBC이용 직접 구현 || Persistence Framework 이용

## Persistence Framework

데이터베이스, 연동, 간단, 빠른 개발, 안정적 구동

Mybatis(SQL Mapper), Hibernate(ORM)

## JPA 사용이유

### 장점

객체지향, 직관적, 비즈니스 로직에 집중, 생산성 증가, 재사용, 유지보수 편리성, DB에 종속적이지 않음

### 단점

설계 어려움, 난이도 높음, 튜닝 어려움

## JDBC

Java Database Connectivity

DB접근, Java 제공 API, 자바 클래스 표준 집합

특정 DB에 구애 받지 않고 독립적 인터페이스 제공

### JDBC DB 접근법

1. JDBC driver 로딩
2. Connection 맺기
3. SQL 실행
4. 자원(데이터) 반환

## DB 최적화
##### DB 최적화 대상
DB에서 최적화를 할 부분은 크게 Client, Database Engine, Filesystem 세가지!!

##### A. Client
복수 건의 레코드를 한번의 호출로 집합 처리하거나, 두 개 이상의 쿼리를 한 쿼리로 통합 처리함으로써 호출 수를 줄일 수 있습니다.

JDBC Statement는 쿼리 문장 분석, 컴파일, 실행의 단계를 캐싱합니다. PreparedStatement는 처음 한 번만 세 단계를 거친 후 캐시에 담아서 재사용합니다.

DB Connection Pool을 사용하여 객체를 생성하는 부분에서 발생하는 대기시간을 줄이고 네트워크 부담을 줄일 수 있습니다.

Fetchsize 조정하거나 Paging을 활용합니다.

##### B. Database Engine
파일시스템에 저장된 데이터가 조회되면 해당 데이터를 메모리에 저장해 이후 동일 데이터 조회 시 파일시스템의 물리적인 입출력이 발생하지 않도록 합니다.

서버 파라미터를 튜닝합니다.

##### C. Filesystem
SSD를 사용합니다.
SQL을 최적화하여 필요이상의 데이터 블록을 읽는 것을 방지합니다. 즉, SQL 튜닝이란 읽는 블록 수를 줄여주는 것을 의미합니다.
